/*!

@page OCHowTo How To... Guides

@ref Guide_Representative_Devices "Sample representative devices used in these tutorials"

@ref Guide_Stack_Init "How to initialize the stack"

@ref Guide_Register_Resource "How to register a resource"

@ref Guide_Find_Resource "How to find a resource"

@ref Guide_PUT  "How to set resource state [PUT]"

@ref Guide_GET "How to query resource state [GET]"

@ref Guide_Observe "How to observe resource state [Observe]"



********************************************************************


@page Guide_Representative_Devices Representative Devices

The best way to understand the concepts for IoTivity is through following an example and understanding the use case. The following devices are referred to throughout this document for use cases and basic operations. The details are listed here for reference so that implementers can compare the responses from these devices with their configuration to develop an understanding of what the responses mean.

@section Rep_Light_Device Light devices (192.168.1.11-13)

A lighting device that can handle up to two light bulbs with dimmers. Each light bulb resource has two attributes:
\li Power: controls power and can have a value of 0 (off) or 1 (on)
\li Level: current dimmer level with a value from 1 (low) to 10 (full)

The separation of the attributes allows the light to return to the previous light level when the power is toggled.

@subsection Rep_Light_Device_Description Description of resources on this device type

<table cellspacing="0" cellpadding="0" border=1 >

<tr>
<td valign="top" ><b>Resource</b></td>
<td valign="top" ><b>Description</b></td>
</tr>

<tr>
<td valign="top" ><p>/oc/core</p></td>
<td valign="top" ><p>Standard resource listing in JSON format.</p></td>
</tr>

<tr>
<td valign="top" ><p>/oc/core/d</p></td>
<td valign="top" ><p>Virtual (hidden) resource that describes the device. It is searchable and supports the JSON attributes listed in the appendix.</p></td>
</tr>

<tr>
<td valign="top" ><p>/lights</p></td>
<td valign="top" ><p>The resource collection that contains light resources</p>

<p>rt=alpha.light</p>

<p>if=oc.mi.ll (linked-list)</p></td>
</tr>

<tr>
<td valign="top" ><p>/light/1</p></td>
<td valign="top" ><p>The resource associated with the first light bulb attached to this device </p>

<p>rt=alpha.light</p>

<p>if=oc.mi.def (default)</p></td>
</tr>

<tr>
<td valign="top" ><p>/light/2</p></td>
<td valign="top" ><p>The resource associated with the second light bulb attached to this device</p>

<p>rt=alpha.light</p>

<p>if=oc.mi.def (default)</p></td>
</tr>

</table>



@subsection Rep_Light_Device_Resource_11 Resource(s) at 192.168.1.11

This device contains a single light resource. The following lists the valid resources and their typical state:

<table cellspacing="0" cellpadding="0" border=1>

<tr>
<td valign="top" ><b>Resource</b></td>
<td valign="top" ><b>Representation</b></td>
</tr>

<tr>
<td valign="top" ><p>/oc/core</p></td>
<td valign="top" ><p>[</p>

<p>{ "href" : "/lights", "rt" : ["alpha.light"], "if" : ["oc.mi.ll"]},</p>

<p>{ "href" : "/light/1", "rt" : ["alpha.light"], "if" : ["oc.mi.def"], "obs" : 1}</p>

<p>]</p></td>
</tr>

<tr>
<td valign="top" ><p>/oc/core/d</p></td>
<td valign="top" ><p>{</p>

<p>"di" : "12345678-1234-1234-0000000000000011",</p>

<p>"dn" : "Alpha Light Controller",</p>

<p>"dd" : "A Light Controller"</p>

<p>}</p></td>
</tr>

<tr>
<td valign="top" ><p>/light/1</p></td>
<td valign="top" ><p>{ "power" : 0, "level" : 4 }</p></td>
</tr>

</table>




@subsection Rep_Light_Device_Resource_12 Resource(s) at 192.168.1.12

This device contains a single light resource. The following lists the valid resources and their typical state:

<table cellspacing="0" cellpadding="0" border=1>

<tr>
<td valign="top" ><b>Resource</b></td>
<td valign="top" ><b>Representation</b></td>
</tr>

<tr>
<td valign="top" ><p>/oc/core</p></td>
<td valign="top" ><p>[</p>

<p>{ "href" : "/lights", "rt" : ["alpha.light"], "if" : ["oc.mi.ll"]},</p>

<p>{ "href" : "/light/2", "rt" : ["alpha.light"], "if" : ["oc.mi.def"], "obs":1}</p>

<p>]</p></td>
</tr>

<tr>
<td valign="top" ><p>/oc/core/d</p></td>
<td valign="top" ><p>{</p>

<p>"di" : "12345678-1234-1234-0000000000000012",</p>

<p>"dn" : "Alpha Light Controller",</p>

<p>"dd" : "A Light Controller"</p>

<p>}</p></td>
</tr>

<tr>
<td valign="top" ><p>/light/2</p></td>
<td valign="top" ><p>{ "power" : 1, "level" : 6 }</p></td>
</tr>

</table>



@subsection Rep_Light_Device_Resource_13 Resource(s) at 192.168.1.13

This device contains two light resources. The following lists the valid resources and their typical state:

<table cellspacing="0" cellpadding="0" border=1> 

<tr>
<td valign="top" ><p>Resource</p></td>
<td valign="top" ><p>Representation</p></td>
</tr>

<tr>
<td valign="top" ><p>/oc/core</p></td>
<td valign="top" ><p>[</p>

<p>{ "href" : "/lights", "rt" : ["alpha.light"], "if" : ["oc.mi.ll"]},</p>

<p>{ "href" : "/light/1", "rt" : ["alpha.light"], "if" : ["oc.mi.def"], "obs":1},</p>

<p>{ "href" : "/light/2", "rt" : ["alpha.light"], "if" : ["oc.mi.def"], "obs":1}</p>

<p>]</p></td>
</tr>

<tr>
<td valign="top" ><p>/oc/core/d</p></td>
<td valign="top" ><p>{</p>

<p>"di" : "12345678-1234-1234-0000000000000013",</p>

<p>"dn" : "Alpha Light Controller",</p>

<p>"dd" : "A Light Controller"</p>

<p>}</p></td>
</tr>

<tr>
<td valign="top" ><p>/light/1</p></td>
<td valign="top" ><p>{ "power" : 0, "level" : 8 }</p></td>
</tr>

<tr>
<td valign="top" ><p>/light/2</p></td>
<td valign="top" ><p>{ "power" : 1, "level" : 10 }</p></td>
</tr>

</table>



@page Guide_Stack_Init Stack Initialization

@section Stack_Init_SD Sequence Diagram

@image html seq_stack_init.png

@note API calls take only important parameters. We omitted some of the parameters for clarity.

The asynchronous processing block handles incoming network traffic including packet processing, scheduled tasks including communication timeouts and callbacks to the application resulting from these activities.
 
@section Stack_Init_CPP Stack Initialization in C++

@code {.cpp}
    // Create PlatformConfig object
    PlatformConfig cfg;
    cfg.ipAddress = "134.134.161.33";
    cfg.port = 5683;
    cfg.mode = ModeType::Client;
    cfg.serviceType = ServiceType::InProc;

    // Create a OCPlatform instance.
    // Note: Platform creation is synchronous call.
    try
    {
        OCPlatform platform(cfg);
    }catch(OCException& e)
    {
        //Handle error
    }
 @endcode

Stack initialization in C++ consists of:
@li Creating a OCPlatform object with Platform configuration which allows definition of role operation (server or client), stack operation (in-process or out-of-process), etc.
@note
@li This is a synchronous call. The application will receive an exception if platform object creation fails.
@li The C++ SDK handles all of the memory allocation and collection. Therefore, the application need not worry about memory management related to the stack.
@li Platform creation happens on the main thread while the message pump happens on a worker thread.





********************************************************************

@page Guide_Register_Resource Registering A Resource

Registering a resource requires two basic items:
\li A handler to process requests from the stack, and
\li A URI path to register the resource. 
The URI path should be rooted (in other words, start with a slash). The stack will construct the fully qualified URI by adding the URI authority to the provided URI path. For example, given a service running on port 5683 in a device at IP address 192.168.1.1, if the application registers a resource with a URI path "/light/1", the resulting fully qualified URI is "oc://192.168.1.1:5683/light/1", which uniquely identifies the resource's location (IP address port and path).
@note Only one resource can be registered at a given URI.
 
@image HTML seq_register_resource_2.png

@section Register_Resource_SD Sequence Diagram
The following call sequence diagram outlines the operations performed in the stack when a resource is registered:

@image HTML seq_register_resource.png

<b>Step 1</b>:
Assuming the application has created a valid OCPlatform object, the application registers a new resource with the stack by calling OCPlatform::registerResource(...).

In this example, the call would take the form:

	platform.registerResource(&handle, "/light/1", "light", "oc.mi.def", handler, OC_DISCOVERABLE)

The handle is a reference to the resource that is used on other APIs. The URI path ("/light/1") is where on this server that the resource can be located. The URI path is unique; this call will fail if the application attempts to register another resource using an existing URI. The resource type ("light") and interface ("oc.mi.def") are properties of the resource used in the discovery process. The handler is a function called from the stack to process requests. The flags control how the stack should handle the resource. The OC_DISCOVERABLE flag indicates that the resource should be reported if a client performs a resource discovery on this server.

<b>Step 2</b>:

The OCPlatform::registerResource(...) method delegates the call to the appropriate instance of the stack (in-process or out-of-process via IPC).

<b>Step 3</b>:
The internal registerResource(...) method constructs a C++ entity handler and registers it with the C SDK using OCCreateResource(...).

In this example, the call would take the form:

	OCCreateResource(&handle, "light", "oc.mi.def", "/light/1", handler, OC_ DISCOVERABLE)

Many of these parameters are passed through to the C SDK directly. However, the entity handler is a proxy function for the handler passed from OCPlatform::registerResource(...).
 
@section Register_Resource_CPP Register Resource in C++ [Server]

@code{.cpp}
    OCResourceHandle resourceHandle;
    std::string resourceURI = "/light/1"; 
    std::string resourceTypeName = "alpha.light
    std::string resourceInterface = DEFAULT_INTERFACE; 
    uint8_t resourceProperty = OC_DISCOVERABLE | OC_OBSERVABLE;

    OCStackResult result = platform.registerResource(resourceHandle, 
                                                        resourceURI,
                                                        resourceTypeName,
                                                        resourceInterface,
                                                        &entityHandler,
                                                        resourceProperty);

    if (OC_STACK_OK == result)
    {
        //Successfull
    }


@endcode



********************************************************************

@page Guide_Find_Resource Finding A Resource

This operation returns all resources of given type on the network service. This operation is sent via multicast to all services. However, the filter limits the responders to just those that support the resource type in the query. Currently only exact matches are supported.

@image HTML seq_find_resource_2.png

@section Find_Resource_SD Sequence Diagram

The following sequence diagram illustrates the resource discovery process over the network when using CoAP. The mechanism is different for Bluetooth, SSDP/HTTP, etc. In the case of CoAP, a 'get' request is sent via multicast to all IoTivity devices. Each device processes the query and responds if the request filter is satisfied. 

In the following example, the client requests all of the light resources with a resource type (rt). Both lights respond to the request, but the fan does not.

@image HTML seq_find_resource_3.png


The following sequence diagram describes the call sequence for discovery from the client side.
@image HTML seq_find_resource.png

Notes:
\li Assuming that the client has a properly initialized OCPlatform object, a C++ SDK client can discover resources by calling OCPlatform::findResources(...).

In this example, the call would take the form:

	platform.findResources("", "/oc/core?rt=alpha.light", findHandler)

The first parameter is the URI authority (target host), which, when empty, indicates that this is for all nodes. The second parameter ("/oc/core?rt=alpha.light") is the URI path and URI query. The URI path ("/oc/core") indicates the resource and the URI query ("rt=alpha.light") is the filter.

\li The SDK call findResources(...) internally delegates the call directly to the in-process or to the out-of process stack via IPC based on the stack configuration.
\li Within the stack, findResource(...) calls the C API function OCDoResource(...). In this example, the call is OCDoResource(&handle, OC_REST_GET, "/oc/core?rt=alpha.light", 0, 0, OC_NON_CONFIRMABLE,  ...)
\li OCDoResource determines which transport is needed to dispatch the request and delegates the call. In the case of CoAP, the following calls are made:
	- Calls OCDoCoapResource(OC_REST_GET, OC_NON_CONFIRMABLE, token, "/oc/core?rt=alpha.light", 0). The token in this example is a nonce that ties a CoAP response back to the CoAP request. Internally, this method creates the CoAP PDU for dispatching.
	- Calls coap_send(context, host, pdu), which is a wrapper for the implementation below.
	- Calls coap_send_impl(context, host, packet), which dispatches the packet to the socket and does the appropriate CoAP bookkeeping.
	- Calls OCSend(socket, buffer, size...), which is a wrapper for the socket implementation as the functions for dispatching a UDP packet can vary in the embedded systems.
\li Servers that offer the resource on the network will reply to the query. The message pump that is evoked from the OCProcess(...) function in the C SDK receives these response packets and dispatches them to the callback associated with the original request based on the CoAP message ID. These responses will come back at the timing defined by their servers. The client stack has timeouts for these responses that are listed in the appendices.
\li As previously mentioned, the stack matches the response to the original request using the message ID and send the results to the callback associated with the request. At this level, the raw payload is presented in JSON format. It is the responsibility of the callback passed to OCDoResource(...) to parse this result.
\li The C++ SDK provides a callback to OCDoResource(...) that will parse the results, construct collections of OCResource objects from the response, and pass them to a C++ client using the handler passed to the platform.findResource(...) method. The handler will be called once for each resource server that responds to the query.

Notes:
\li Some of the API call parameters have been omitted for brevity.
\li The findResource() method can be used in the following ways:
	- Find all resources on the network that match the provided criteria
	- Query a specific (single) server for the resources that it provides matching the provided criteria
\li The findResource() method may be used multiple times to find a resource
\li The findResource() callback is called from the message pump thread in multithreaded environments
\li Blocking in the findResource() callback will block other stack processing including servicing the network I/O which can cause delays and missed packets.

<b>Detailed server call sequence diagram</b>
The following sequence diagram illustrates the call sequence for discovery from the server side. 

@note When the request is sent to all nodes, all nodes will run through this sequence.

@image HTML seq_find_resource_4.png

Notes:
\li The discovery request under CoAP is handled like any other resource GET request. The request can be received via unicast or multicast, but the response, if any, is always sent via unicast.
\li The stack dispatches the request to an entity handler that is defined by the stack.
\li The handler for "/oc/core", processes the URI query, if any, and builds a list of resources that match the criteria and returns the result in JSON to the network transport.
\li In the case of CoAP, if the request is made to all nodes (multicast) and the resource list is empty, no response is sent to the clients. If the request is directed (unicast) or the resource list has results, the response is sent unicast back the client.


@section Find_Resource_CPP Register Resource in C++ [Client]

@code{.cpp}
// Callback to found resources
    void foundResource(std::shared_ptr<OCResource> resource)
    {
            
    std::string resourceURI;
    std::string hostAddress;
    try
    {
        // Do some operations with resource object.
        if(resource)
        {
            std::cout<<"DISCOVERED Resource:"<<std::endl;
            // Get the resource URI
            resourceURI = resource->uri();
            std::cout << "\tURI of the resource: " << resourceURI << std::endl;

            // Get the resource host address
            hostAddress = resource->host();
            std::cout << "\tHost address of the resource: " << hostAddress << std::endl;

            // Get the resource types
            std::cout << "\tList of resource types: " << std::endl;
            for(auto &resourceTypes : resource->getResourceTypes())
            {
                std::cout << "\t\t" << resourceTypes << std::endl;
            }

            // Get the resource interfaces
            std::cout << "\tList of resource interfaces: " << std::endl;
            for(auto &resourceInterfaces : resource->getResourceInterfaces())
            {
                std::cout << "\t\t" << resourceInterfaces << std::endl;
            }

            if(resourceURI == "/a/light1")
            {
                // Found interested resource
            }
        }
        else
        {
            // Resource is invalid
            std::cout << "Resource is invalid" << std::endl;
        }

    }
    catch(std::exception& e)
    {
        //log
    }

    }


    try
    {
        OCPlatform platform(cfg);

        // Find all resources
        platform.findResource("", "coap://224.0.1.187/oc/core?rt=alpha.light", &foundResource);

    }catch(OCException& e)
    {
        //Handle Error
    }


@endcode

@section Find_Resource_OTA_Request Over the air Request

The request is sent to all nodes on the network:

<table cellspacing="0" cellpadding="0" border=1>

<tr>
<td valign="top" ><p>Field</p></td>
<td valign="top" ><p>Value</p></td>
<td valign="top" ><p>Note(s)</p></td>
</tr>

<tr>
<td valign="top" ><p>Address</p></td>
<td valign="top" ><p>224.0.1.187:5683</p></td>
<td valign="top" ><p>Multicast packet</p></td>
</tr>

<tr>
<td valign="top" ><p>Header</p></td>
<td valign="top" ><p>NON, GET, MID=0x7d40</p></td>
<td valign="top" ><p>Multicast discovery request should be non-confirmable</p></td>
</tr>

<tr>
<td valign="top" ><p>URI-Path</p></td>
<td valign="top" ><p>oc</p></td>
<td rowspan="3" valign="top" ><p>"/oc/core?rt=alpha.light"</p></td>
</tr>

<tr>
<td valign="top" ><p>URI-Path</p></td>
<td valign="top" ><p>core</p></td>
</tr>

<tr>
<td valign="top" ><p>URI-Query</p></td>
<td valign="top" ><p>rt=alpha.light</p></td>
<td valign="middle" ><p><br />
</p></td>
</tr>

<tr>
<td valign="top" ><p>Accept</p></td>
<td valign="top" ><p>application/json</p></td>
<td valign="top" ><p><br />
</p></td>
</tr>


</table>



@section Find_Resource_OTA_Response Over the air Response(s)

Assuming that all of the representative devices (see @ref Guide_Representative_Devices "Representative Devices") are online, three responses are expected. Only the three devices with light resources respond; the list of resources has been filtered to contain just the resources that match the criteria.

<b>From 192.168.1.11</b>:

<table cellspacing="0" cellpadding="0" border=1> 
<tr>
<td valign="top" ><p>Field</p></td>
<td valign="top" ><p>Value</p></td>
<td valign="top" ><p>Explanation</p></td>
</tr>

<tr>
<td valign="top" ><p>Address</p></td>
<td valign="top" ><p>192.168.1.1:5683</p></td>
<td valign="top" ><p>Client Address</p></td>
</tr>

<tr>
<td valign="top" ><p>Header</p></td>
<td valign="top" ><p>ACK, CONTENT, MID=0x7d40</p></td>
<td valign="top" ><p>Success w/content</p></td>
</tr>

<tr>
<td valign="top" ><p>Content</p>

<p>Format</p></td>
<td valign="top" ><p>application/json</p></td>
<td valign="top" ><p><br />
</p></td>
</tr>

<tr>
<td valign="top" ><p>Payload</p></td>
<td valign="top" ><p>[</p>

<p>{ "href" : "/light/1", "rt":["alpha.light"], "if":["oc.mi.def"], "obs":1}</p>

<p>]</p></td>
<td valign="top" ><p><br />
</p></td>
</tr>

</table>

<b>From 192.168.1.12</b>:

<table cellspacing="0" cellpadding="0" border=1>

<tr>
<td valign="top" ><p>Field</p></td>
<td valign="top" ><p>Value</p></td>
<td valign="top" ><p>Explanation</p></td>
</tr>

<tr>
<td valign="top" ><p>Address</p></td>
<td valign="top" ><p>192.168.1.1:5683</p></td>
<td valign="top" ><p>Client Address</p></td>
</tr>

<tr>
<td valign="top" ><p>Header</p></td>
<td valign="top" ><p>ACK, CONTENT, MID=0x7d40</p></td>
<td valign="top" ><p>Success w/content</p></td>
</tr>

<tr>
<td valign="top" ><p>Content</p>

<p>Format</p></td>
<td valign="top" ><p>application/json</p></td>
<td valign="top" ><p><br />
</p></td>
</tr>

<tr>
<td valign="top" ><p>Payload</p></td>
<td valign="top" ><p>[</p>

<p>{ "href" : "/light/2", "rt":["alpha.light"], "if":["oc.mi.def"], "obs":1}</p>

<p>]</p></td>
<td valign="top" ><p><br />
</p></td>
</tr>

</table>



<b>From 192.168.1.13</b>:

<table cellspacing="0" cellpadding="0" border=1> 
<tr>
<td valign="top" ><p>Field</p></td>
<td valign="top" ><p>Value</p></td>
<td valign="top" ><p>Explanation</p></td>
</tr>

<tr>
<td valign="top" ><p>Address</p></td>
<td valign="top" ><p>192.168.1.1:5683</p></td>
<td valign="top" ><p>Client Address</p></td>
</tr>

<tr>
<td valign="top" ><p>Header</p></td>
<td valign="top" ><p>ACK, CONTENT, MID=0x7d40</p></td>
<td valign="top" ><p>Success w/content</p></td>
</tr>

<tr>
<td valign="top" ><p>Content</p>

<p>Format</p></td>
<td valign="top" ><p>application/json</p></td>
<td valign="top" ><p><br />
</p></td>
</tr>

<tr>
<td valign="top" ><p>Payload</p></td>
<td valign="top" ><p>[</p>

<p>{ "href" : "/light/1", "rt":["alpha.light"], "if":["oc.mi.def"], "obs":1},</p>

<p>{ "href" : "/light/2", "rt":["alpha.light"], "if":["oc.mi.def"], "obs":1}</p>

<p>]</p></td>
<td valign="top" ><p><br />
</p></td>
</tr>

</table>



********************************************************************

@page Guide_PUT Setting a resource state [PUT]

This operation sets the value of a simple resource. In this example, we turn on a light resource and set the brightness to 50%.

@section PUT_SD Sequence Diagram

@image HTML seq_put.png

Steps:
1.	The client application calls resource.put(...) to set representation of resource. 
Example call: 
resource.put(attributeMap, queryParamsMap, &onPut);   
2.	Client SDK internally calls the setResourceAttributes function of the client wrapper.
Example call:
OCDoResource(OC_REST_PUT, "//192.168.1.11/light/1, 0, 0, OC_CONFIRMABLE, callback);
3.	Send PUT request to remote device
4.	The OCProcess() service function (server-side message pump) reads the packet from the socket and dispatches the request to the entity handler for the provided URI.
5.	The entity handler, which was provided by an upper layer when the resource was registered, parses the representation and in the case of the C++ API passes the results to the upper layer handler. In a C only environment, the results would also be processed in the entity handler.
6.	The upper layer entity handler written by the app developer/vendor is invoked, and response is formed accordingly.
7.	The upper layer entity handler returns success or failure with a response.
8.	Returns   success or failure to lower layer for transmission to client.
9.	Returns success or failure to lower layer for transmission to client.
10.	Returns success or failure to lower layer for transmission to client.
11.	Result is formatted and sent over network to client
12.	The OCProcess() service function (client-side message pump) reads results and passes the results back to the client application via the callback passed to OCDoResource


@section PUT__Client_CPP Set Resource's State [PUT] in C++ [Client]

@code{.cpp}
void putLightRepresentation(std::shared_ptr<OCResource> resource)
{
    if(resource)
    {
        OCRepresentation rep;

        std::cout << "Putting light representation..."<<std::endl;
        // Create AttributeMap
        AttributeMap attributeMap;
        // Add the attribute name and values in the attribute map
        AttributeValues stateVal;
        stateVal.push_back("true");

        AttributeValues powerVal;
        powerVal.push_back("10");

        attributeMap["state"] = stateVal;
        attributeMap["power"] = powerVal;

        // Create QueryParameters Map and add query params (if any)
        QueryParamsMap queryParamsMap;

        rep.setAttributeMap(attributeMap);

        // Invoke resource's put API with attribute map, query map and the callback parameter
        resource->put(rep, queryParamsMap, &onPut);
    }
}

// callback handler on PUT request
void onPut(const OCRepresentation& rep, const int eCode)
{
    if(eCode == SUCCESS_RESPONSE)
    {
        std::cout << "PUT request was successful" << std::endl;

        AttributeMap attributeMap = rep.getAttributeMap();

        for(auto it = attributeMap.begin(); it != attributeMap.end(); ++it)
        {
            std::cout << "\tAttribute name: "<< it->first << " value: ";
            for(auto valueItr = it->second.begin(); valueItr != it->second.end(); ++valueItr)
            {
                std::cout <<"\t"<< *valueItr << " ";
            }

            std::cout << std::endl;
        }

        std::vector<OCRepresentation> children = rep.getChildren();

        for(auto oit = children.begin(); oit != children.end(); ++oit)
        {
            attributeMap = oit->getAttributeMap();

            for(auto it = attributeMap.begin(); it != attributeMap.end(); ++it)
            {
                std::cout << "\tAttribute name: "<< it->first << " value: ";
                for(auto valueItr = it->second.begin(); valueItr != it->second.end(); ++valueItr)
                {
                    std::cout <<"\t"<< *valueItr << " ";
                }

                std::cout << std::endl;
            }
        }

    }
    else
    {
        std::cout << "onPut Response error: " << eCode << std::endl;
        std::exit(-1);
    }
}

@endcode

@section PUT_Server_CPP Set Resource's State [PUT] in C++ [Server]

@code{.cpp}
//Entity handle sample for PUT
            if(requestType == "PUT")
            {
                cout << "\t\t\trequestType : PUT\n";

                // Check for query params (if any)
                QueryParamsMap queryParamsMap = request->getQueryParameters();

                cout << "\t\t\tquery params: \n";
                for(auto it = queryParamsMap.begin(); it != queryParamsMap.end(); it++)
                {
                    cout << "\t\t\t\t" << it->first << ":" << it->second << endl;
                }

                // Get the representation from the request
                OCRepresentation rep = request->getResourceRepresentation();

                myLightResource.setRepresentation(rep); // See code snippet below

                // Do related operations related to PUT request // See code snippet below
                rep = myLightResource.getRepresentation();

                if(response)
                {
                    
                    response->setErrorCode(200);

                    auto findRes = queryParamsMap.find("if");

                    if(findRes != queryParamsMap.end())
                    {
                        response->setResourceRepresentation(rep, findRes->second);
                    }
                    else
                    {
                        response->setResourceRepresentation(rep, DEFAULT_INTERFACE);
                    }
                }
}

    void setRepresentation(OCRepresentation& light)
    {
        AttributeMap attributeMap = light.getAttributeMap();

        if(attributeMap.find("state") != attributeMap.end() && attributeMap.find("power") != attributeMap.end())
        {
            cout << "\t\t\t" << "Received representation: " << endl;
            cout << "\t\t\t\t" << "power: " << attributeMap["power"][0] << endl;
            cout << "\t\t\t\t" << "state: " << attributeMap["state"][0] << endl;

            m_state = attributeMap["state"][0].compare("true") == 0;
            m_power= std::stoi(attributeMap["power"][0]);
        }
    }

    OCRepresentation getRepresentation()
    {
        OCRepresentation light;

        light.setUri(m_lightUri);

        std::vector<std::string> interfaces;
        //interfaces.push_back(m_lightInterface);

        light.setResourceInterfaces(interfaces);

        std::vector<std::string> types;
        //types.push_back(m_lightType);

        light.setResourceTypes(types);

        AttributeMap attributeMap;
        AttributeValues stateVal;
        if(m_state)
        {
            stateVal.push_back("true");
        }
        else
        {
            stateVal.push_back("false");
        }

        AttributeValues powerVal;
        powerVal.push_back(to_string(m_power));

        attributeMap["state"] = stateVal;
        attributeMap["power"] = powerVal;

        light.setAttributeMap(attributeMap);

        return light;
    }

@endcode


@section PUT_OTA_Response Over the air request

In this example, we are pushing state to one of the lights. At this point, the resource was discovered by its type, and we understand its interface and the attributes exposed by the resource.

<table cellspacing="0" cellpadding="0" border=1> 

<tr>
<td valign="top" ><p>Field</p></td>
<td valign="top" ><p>Value</p></td>
<td valign="top" ><p>Note(s)</p></td>
</tr>

<tr>
<td valign="top" ><p>Address</p></td>
<td valign="top" ><p>192.168.1.13:5683</p></td>
<td valign="top" ><p>Unicast packet</p></td>
</tr>

<tr>
<td valign="top" ><p>Header</p></td>
<td valign="top" ><p>CON, PUT, MID=0x7d41</p></td>
<td valign="top" ><p>Confirmation is requested</p></td>
</tr>

<tr>
<td valign="top" ><p>URI-Path</p></td>
<td valign="top" ><p>light</p></td>
<td rowspan="2" valign="top" ><p>"/light/1"</p></td>
</tr>

<tr>
<td valign="top" ><p>URI-Path</p></td>
<td valign="top" ><p>1</p></td>
</tr>

<tr>
<td valign="top" ><p>Content-Type</p></td>
<td valign="top" ><p>application/json</p></td>
<td valign="top" ><p><br />
</p></td>
</tr>

<tr>
<td valign="top" ><p>Payload</p></td>
<td valign="top" ><p>{</p>

<p>"power" : 1,</p>

<p>"level" : 5</p>

<p>}</p></td>
<td valign="top" ><p><br />
</p></td>
</tr>

</table>


@section PUT_OTA_Response Over the air response(s)

Assuming that the request is valid and the resource is able to complete the transition, the following represents a successful change in state.

<b>From 192.168.1.13</b>:

<table cellspacing="0" cellpadding="0" border=1> 

<tr>
<td valign="top" ><p>Field</p></td>
<td valign="top" ><p>Value</p></td>
<td valign="top" ><p>Explanation</p></td>
</tr>

<tr>
<td valign="top" ><p>Address</p></td>
<td valign="top" ><p>192.168.1.1:5683</p></td>
<td valign="top" ><p>Client Address</p></td>
</tr>

<tr>
<td valign="top" ><p>Header</p></td>
<td valign="top" ><p>ACK, CHANGED, MID=0x7d41</p></td>
<td valign="top" ><p>Success (changed)</p></td>
</tr>

</table>



**********************************************************************

@page Guide_GET Querying resource State [GET]

This operation fetches the value of a simple resource. In this example, we fetch the state from the light resource.

@section GET_SD Sequence Diagram
@image HTML seq_get.png

Steps:
1.	The client application calls resource.get(...) to retrieve a representation from the resources.
2.	The call is marshalled to the stack which is either running in-process or out-of-process (daemon).
3.	The C API is called to dispatch the request. The call may look like the following:
OCDoResource(OC_REST_GET, "//192.168.1.11/light/1, 0, 0, OC_CONFIRMABLE, callback); 
4.	Where CoAP is used as a transport, the lower stack will send a GET request to the target server.
5.	On the server side, the OCProcess() function (message pump) receives and parses the request from the socket, then dispatches it to the correct entity handler based on the URI of the request.
6.	Where the C++ API is used, the C++ entity handler parses the payload and marshals it to the client application depending on if the server stack is running in-process or out-of-process (daemon).
7.	The C++ SDK passes it up the C++ handler associated with the OCResource.
8.	The handler returns the result code and representation to the SDK.
9.	The SDK marshals the result code and representation to the C++ entity handler.
10.	The entity handler returns the result code and representation to the CoAP protocol.
11.	The CoAP protocol transports the results to the client device.
12.	The results are returned the OCDoResource callback.
13.	The results are returned to the C++ client application's asyncResultCallback.

@section GET_Client_CPP Querying resource State [GET] in C++ [Client]
@code{.cpp}
// Local function to get representation of light resource
void getLightRepresentation(std::shared_ptr<OCResource> resource)
{
    if(resource)
    {
        std::cout << "Getting Light Representation..."<<std::endl;
        // Invoke resource's get API with the callback parameter

        QueryParamsMap test;
        resource->get(test, &onGet);
    }
}

// callback handler on GET request
void onGet(const OCRepresentation& rep, const int eCode)
{
    if(eCode == SUCCESS_RESPONSE)
    {
        std::cout << "GET request was successful" << std::endl;

        AttributeMap attributeMap = rep.getAttributeMap();

        std::cout << "Resource URI: " << rep.getUri() << std::endl;

        for(auto it = attributeMap.begin(); it != attributeMap.end(); ++it)
        {
            std::cout << "\tAttribute name: "<< it->first << " value: ";
            for(auto valueItr = it->second.begin(); valueItr != it->second.end(); ++valueItr)
            {
                std::cout <<"\t"<< *valueItr << " ";
            }

            std::cout << std::endl;
        }

        std::vector<OCRepresentation> children = rep.getChildren();

        for(auto oit = children.begin(); oit != children.end(); ++oit)
        {
            std::cout << "Child Resource URI: " << oit->getUri() << std::endl;

            attributeMap = oit->getAttributeMap();

            for(auto it = attributeMap.begin(); it != attributeMap.end(); ++it)
            {
                std::cout << "\tAttribute name: "<< it->first << " value: ";
                for(auto valueItr = it->second.begin(); valueItr != it->second.end(); ++valueItr)
                {
                    std::cout <<"\t"<< *valueItr << " ";
                }

                std::cout << std::endl;
            }
        }

        putLightRepresentation(curResource);
    }
    else
    {
        std::cout << "onGET Response error: " << eCode << std::endl;
        std::exit(-1);
    }
}


@endcode

@section GET_Server_CPP Querying resource State [GET] in C++ [Server]
@code{.cpp}

// Handling GET request in Entity handler            
if(requestType == "GET")
            {
                cout << "\t\t\trequestType : GET\n";

                // Check for query params (if any)
                QueryParamsMap queryParamsMap = request->getQueryParameters();

                cout << "\t\t\tquery params: \n";
                for(QueryParamsMap::iterator it = queryParamsMap.begin(); it != queryParamsMap.end(); it++)
                {
                    cout << "\t\t\t\t" << it->first << ":" << it->second << endl;
                }

                // Process query params and do required operations ..

                // Get the representation of this resource at this point and send it as response
                // AttributeMap attributeMap;
                OCRepresentation rep;
                rep = myLightResource.getRepresentation();

                if(response)
                {
                    // TODO Error Code
                    response->setErrorCode(200);

                    auto findRes = queryParamsMap.find("if");

                    if(findRes != queryParamsMap.end())
                    {
                        response->setResourceRepresentation(rep, findRes->second);
                    }
                    else
                    {
                        response->setResourceRepresentation(rep, DEFAULT_INTERFACE);
                    }
                }
            }


@endcode


@section GET_OTA_Response Over the air request

In this example, we are querying state from one of the lights. At this point, the resource was discovered by its type, and we understand its interface and the attributes that the resource exposes.

<table cellspacing="0" cellpadding="0" border=1>

<tr>
<td valign="top" ><p>Field</p></td>
<td valign="top" ><p>Value</p></td>
<td valign="top" ><p>Note(s)</p></td>
</tr>

<tr>
<td valign="top" ><p>Address</p></td>
<td valign="top" ><p>192.168.1.11:5683</p></td>
<td valign="top" ><p>Unicast packet</p></td>
</tr>

<tr>
<td valign="top" ><p>Header</p></td>
<td valign="top" ><p>CON, GET, MID=0x7d42</p></td>
<td valign="top" ><p>Confirmation is requested</p></td>
</tr>

<tr>
<td valign="top" ><p>URI-Path</p></td>
<td valign="top" ><p>light</p></td>
<td rowspan="2" valign="top" ><p>"/light/1"</p></td>
</tr>

<tr>
<td valign="top" ><p>URI-Path</p></td>
<td valign="top" ><p>1</p></td>
</tr>

<tr>
<td valign="top" ><p>Accept</p></td>
<td valign="top" ><p>application/json</p></td>
<td valign="top" ><p><br />
</p></td>
</tr>

</table>



@section GET_OTA_Response Over the air response(s)

Assuming that the request is valid, we expect the following reply from the resource.

<b>From 192.168.1.11</b>:

<table cellspacing="0" cellpadding="0" border=1> 
<tr>
<td valign="top" ><p>Field</p></td>
<td valign="top" ><p>Value</p></td>
<td valign="top" ><p>Explanation</p></td>
</tr>

<tr>
<td valign="top" ><p>Address</p></td>
<td valign="top" ><p>192.168.1.1:5683</p></td>
<td valign="top" ><p>Client Address</p></td>
</tr>

<tr>
<td valign="top" ><p>Header</p></td>
<td valign="top" ><p>ACK, CONTENT, MID=0x7d42</p></td>
<td valign="top" ><p>Success w/Content</p></td>
</tr>

<tr>
<td valign="top" ><p>Content</p>

<p>Type</p></td>
<td valign="top" ><p>application/json</p></td>
<td valign="top" ><p><br />
</p></td>
</tr>

<tr>
<td valign="top" ><p>Payload</p></td>
<td valign="top" ><p>{</p>

<p>"power" : 0,</p>

<p>"level" : 10</p>

<p>}</p></td>
<td valign="top" ><p><br />
</p></td>
</tr>

</table>




**********************************************************************

@page Guide_Observe Observing resource state [Observe]

This operation fetches and registers as an observer for the value of a simple resource. In this example, we fetch the state of the light resource. For more implementation details, see "Observing Resources in CoAP" listed in the referenced documents. (https://datatracker.ietf.org/doc/draft-ietf-core-observe/?include_text=1)

The handling of observation registration is application specific. It should not be assumed that a resource is observable, or a resource can handle any specific number of observers. If the server responds with a success (2.xx) code, the registration is considered successful.

Notifications from the server to the client may be confirmable or non-confirmable. If the client returns a RST message, the observation registration should be dropped immediately. If the client fails to acknowledge a number of confirmable requests, the server should assume that the client has abandoned the observation and drop the registration.

If the observed resource is removed, the server sends a NOTFOUND status to all observers.

If an observed resource fails to notify a client before the max-age of a resource value update, the client should attempt to re-register the observation.


@section Observe_SD Sequence Diagram
@image HTML seq_observe.png

Steps:
1.	The client application calls resource.observe(...) to retrieve a representation from the resources.
2.	The call is marshalled to the stack which is either running in-process or out-of-process (daemon).
3.	The C API is called to dispatch the request. The call may look like this:
OCDoResource(OC_REST_GET | OC_REST_OBSERVE, "//192.168.1.11/light/1, 0, 0, OC_CONFIRMABLE, callback);
4.	Where CoAP is used as a transport, the lower stack will send a GET request to the target server. The primary difference between a GET request and an observe request is that the observe request contains an observe option indicating that, in addition to querying this resource, the client wishes to get notifications if/when the resource state changes.
5.	On the server side, the OCProcess() function (message pump) receives and parses the request from the socket, then dispatches it to the correct entity handler based on the URI of the request. The request to the entity handler will indicate that the request is both a query and subscription request. The entity handler MAY take note of this, but it is not responsible to tracking the observers. The stack tracks the observers of record.
6.	Where the C++ API is used the C++ entity handler parses the payload and marshals it to the client application depending on if the server stack is running in-process or out-of-process (daemon).
7.	The C++ SDK passes it up the C++ handler associated with the OCResource.
8.	The handler returns the result code and representation to the SDK.
9.	The SDK marshals the result code and representation to the C++ entity handler.
10.	The entity handler returns the result code and representation to the CoAP protocol.
11.	The CoAP protocol transport the results to the client device.
12.	The results are returned to the OCDoResource callback.
13.	The results are returned to the C++ client application's asyncResultCallback.
14.	If the entity handler has registered   observers, it will periodically be called with the observe flag set so that it may sample or poll underlying hardware to determine if the state has changes.
15.	When the application has deemed that the resource state has changed either via polling (entity handler observe) or via external signal, the application should call OCNotifyObservers(). This tells the stack the observers need updating.
16.	For each observer of a changed resource, the entity handler is called to generate a representation that is transmitted to the observing clients. 
17.	Where CoAP is used as a transport, a packet with content is sent to the devices that have observing clients. The packets may be confirmable or non-confirmable based on application needs.
18.	The client-side OCProcess function (message pump) receives the message and matches it to the original request based on the CoAP token ID and dispatches the appropriate 
C API callback.
19.	The C API callback passes the final results to the C++ client application's asyncResultCallback.
20.	When the C++ client no longer desires to receive notifications from the server, it calls observation cancellation method cancelObserve(). 
21.	The C++ cancellation method calls the OCCancel() function from the C API.
22.	OCCancel() finds the observation that is associated with the operation and sends an observe deregistration request to the server.


@section Observe_Client_CPP Observing resource state [Observe] in C++ [Client]
@code{.cpp}
      if (OBSERVE_TYPE_TO_USE == ObserveType::Observe)
            std::cout << endl << "Observe is used." << endl << endl;
        else if (OBSERVE_TYPE_TO_USE == ObserveType::ObserveAll)
            std::cout << endl << "ObserveAll is used." << endl << endl;

        QueryParamsMap test;

        curResource->observe(OBSERVE_TYPE_TO_USE, test, &onObserve);

// callback
void onObserve(const OCRepresentation& rep, const int& eCode, const int& sequenceNumber)
{
    if(eCode == SUCCESS_RESPONSE)
    {
        AttributeMap attributeMap = rep.getAttributeMap();

        std::cout << "OBSERVE RESULT:"<<std::endl;
        std::cout << "\tSequenceNumber: "<< sequenceNumber << endl;
        for(auto it = attributeMap.begin(); it != attributeMap.end(); ++it)
        {
            std::cout << "\tAttribute name: "<< it->first << " value: ";
            for(auto valueItr = it->second.begin(); valueItr != it->second.end(); ++valueItr)
            {
                std::cout <<"\t"<< *valueItr << " ";
            }

            std::cout << std::endl;
        }

        if(observe_count() > 30)
        {
            std::cout<<"Cancelling Observe..."<<std::endl;
            OCStackResult result = curResource->cancelObserve();

            std::cout << "Cancel result: "<< result <<std::endl;
            sleep(10);
            std::cout << "DONE"<<std::endl;
            std::exit(0);
        }
    }
    else
    {
        std::cout << "onObserve Response error: " << eCode << std::endl;
        std::exit(-1);
    }
}


@endcode



@section Observe_Server_CPP Observing resource state [Observe] in C++ [Server]
@code{.cpp}
// Handling observe in server's entity handler        
if(requestFlag == RequestHandlerFlag::ObserverFlag)
        {
            pthread_t threadId;

            cout << "\t\trequestFlag : Observer\n";
            gObservation = 1;

            static int startedThread = 0;

            // Observation happens on a different thread in ChangeLightRepresentation function.
            // If we have not created the thread already, we will create one here.
            if(!startedThread)
            {
                pthread_create (&threadId, NULL, ChangeLightRepresentation, (void *)NULL);
                startedThread = 1;
            }

// ChangeLightRepresentaion is an observation function,
// which notifies any changes to the resource to stack
// via notifyObservers
void * ChangeLightRepresentation (void *param)
{
    // This function continuously monitors for the changes
    while (1)
    {
        sleep (5);

        if (gObservation)
        {
            // If under observation if there are any changes to the light resource
            // we call notifyObservors
            //
            // For demostration we are changing the power value and notifying.
            myLightResource.m_power += 10;

            cout << "\nPower updated to : " << myLightResource.m_power << endl;
            cout << "Notifying observers with resource handle: " << myLightResource.getHandle() << endl;

            OCStackResult result = OCPlatform::notifyObservers(myLightResource.getHandle());

            if(OC_STACK_NO_OBSERVERS == result)
            {
                cout << "No More observers, stopping notifications" << endl;
                gObservation = 0;
            }
        }
    }

    return NULL;
}


@endcode




@section Oberve_OTA_Response Over the air request

The following observation request is basically a GET request with the observation option set.

<table cellspacing="0" cellpadding="0" border=1> 
<tr>
<td valign="top" ><p>Fields</p></td>
<td valign="top" ><p>Value</p></td>
<td valign="top" ><p>Notes</p></td>
</tr>

<tr>
<td valign="top" ><p>Address</p></td>
<td valign="top" ><p>192.168.1.11:5683</p></td>
<td valign="top" ><p>Unicast packet</p></td>
</tr>

<tr>
<td valign="top" ><p>Header</p></td>
<td valign="top" ><p>CON, GET, MID=0x7d44, TOK=0x3f</p></td>
<td valign="top" ><p>Confirmation requested</p></td>
</tr>

<tr>
<td valign="top" ><p>Observe</p></td>
<td valign="top" ><p>Register (0)</p></td>
<td valign="top" ><p>This indicates registration</p></td>
</tr>

<tr>
<td valign="top" ><p>URI-Path</p></td>
<td valign="top" ><p>Light</p></td>
<td valign="top" ><p>"/light/1 "</p></td>
</tr>

<tr>
<td valign="top" ><p>URI-Path</p></td>
<td valign="top" ><p>1</p></td>
<td valign="top" ><p><br />
</p></td>
</tr>

<tr>
<td valign="top" ><p>Accept</p></td>
<td valign="top" ><p>application/json</p></td>
<td valign="top" ><p>Requesting result in JSON</p></td>
</tr>

</table>



@section Observe_OTA_Response Over the air response(s)

A successful observe request would be similar to the following:

<table cellspacing="0" cellpadding="0" border=1> 
<tr>
<td valign="top" ><p>Field</p></td>
<td valign="top" ><p>Value</p></td>
<td valign="top" ><p>Explanation</p></td>
</tr>

<tr>
<td valign="top" ><p>Address</p></td>
<td valign="top" ><p>192.168.1.1:5683</p></td>
<td valign="top" ><p>Client Address</p></td>
</tr>

<tr>
<td valign="top" ><p>Header</p></td>
<td valign="top" ><p>ACK, CONTENT, MID=0x7d44, TOK=0x3f</p></td>
<td valign="top" ><p>Success w/content</p></td>
</tr>

<tr>
<td valign="top" ><p>Observe</p></td>
<td valign="top" ><p>12</p></td>
<td valign="top" ><p>Sequence number for ordering</p></td>
</tr>

<tr>
<td valign="top" ><p>Max-Age</p></td>
<td valign="top" ><p>30</p></td>
<td valign="top" ><p>Indicates that the value is fresh for 30 seconds.</p>

<p>It also indicates that the server should send an</p>

<p>update within this time period.</p></td>
</tr>

<tr>
<td valign="top" ><p>Content</p>

<p>Type</p></td>
<td valign="top" ><p>application/json</p></td>
<td valign="top" ><p><br />
</p></td>
</tr>

<tr>
<td valign="top" ><p>Payload</p></td>
<td valign="top" ><p>{</p>

<p>"power" : 0,</p>

<p>"level" : 10</p>

<p>}</p></td>
<td valign="top" ><p><br />
</p></td>
</tr>

</table>

<b>Subsequent Notifications from 192.168.1.1 </b>

If the light resource is being observed and the light transitions from an off state to an on state, a notification is sent to the client from the server. The following is an example of such a notification:


<table cellspacing="0" cellpadding="0" border=1> 
<tr>
<td valign="top" ><p>Field</p></td>
<td valign="top" ><p>Value</p></td>
<td valign="top" ><p>Explanation</p></td>
</tr>

<tr>
<td valign="top" ><p>Address</p></td>
<td valign="top" ><p>192.168.1.1:5683</p></td>
<td valign="top" ><p>Client Address</p></td>
</tr>

<tr>
<td valign="top" ><p>Header</p></td>
<td valign="top" ><p>CON, CONTENT, MID=0x7D45, TOK=0x3f</p></td>
<td valign="top" ><p>Content, Can be confirmable or non-confirmable</p></td>
</tr>

<tr>
<td valign="top" ><p>Observe</p></td>
<td valign="top" ><p>15</p></td>
<td valign="top" ><p>Monotonically increasing until overflow</p></td>
</tr>

<tr>
<td valign="top" ><p>Max-Age</p></td>
<td valign="top" ><p>30</p></td>
<td valign="top" ><p>Indicates that the value is fresh for 30 seconds.</p>

<p>It also indicates that the server should send an</p>

<p>update within this time period.</p></td>
</tr>

<tr>
<td valign="top" ><p>Payload</p></td>
<td valign="top" ><p>{</p>

<p>"power" : 1,</p>

<p>"level" : 10</p>

<p>}</p></td>
<td valign="top" ><p><br />
</p></td>
</tr>

</table>

Since the above notification was marked confirmable, the client should acknowledge the notification with a packet such as the following:

<table cellspacing="0" cellpadding="0" border=1> 

<tr>
<td valign="top" ><p>Field</p></td>
<td valign="top" ><p>Value</p></td>
<td valign="top" ><p>Explanation</p></td>
</tr>

<tr>
<td valign="top" ><p>Address</p></td>
<td valign="top" ><p>192.168.1.11:5683</p></td>
<td valign="top" ><p>Unicast packet</p></td>
</tr>

<tr>
<td valign="top" ><p>Header</p></td>
<td valign="top" ><p>ACK, MID=0x7D45, TOK=0x3f</p></td>
<td valign="top" ><p>Success</p></td>
</tr>

</table>





**********************************************************************


*/
